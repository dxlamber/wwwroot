<!DOCTYPE html>
<html>
<head>
	<title>An Lisp interpretation by Javascript</title>
	<meta charset="UTF-8">
	<link href="/lib/bootstrap/css/bootstrap.css" rel="stylesheet" media="screen">
</head>
<body>
 <p>Test Lisp Expression:</p>
 <div><textarea id="simpleExp" style="height:100px; width:300px;">(+ 12 23)</textarea></div>
 <div><button onclick="calcSimpleExp();">计算</button></div>
</body>
<script src="/lib/jquery/jquery.js"></script>
<script src="/lib/bootstrap/js/bootstrap.js"></script>
<script type="text/javascript">
var GlobalFun = {};
GlobalFun.add = function(){
 return [].reduce.call(arguments, function(pv, cv){return pv+cv;}, 0);
};
GlobalFun.mult = function(){
 debugger;
 return [].reduce.call(arguments, function(pv, cv){return pv*cv;}, 1);
};
GlobalFun.minus = function(){
 if(arguments.length != 2)
 {
	debugger;
	return;
 }
	
 return arguments[0] - arguments[1];
};
GlobalFun.div = function(){
 if(arguments.length != 2)
 {
	debugger;
	return;
 }
	
 return arguments[0] / arguments[1];
};
GlobalFun.note = function(obj){
 return obj.toNote();
};

/*
	var a = new AutoFsm({
		"null": {"d":"start"},
		"start":{"e":"1"},
		"1":{"f":"2"},
		"2":{"u":"3"},
		"3":{"n":"succ"}
	});
	a.test("test defun keyword");
*/

AutoFsm = function(statJump){
	this.statJump = statJump || {"null":false};
};
AutoFsm.separatorVal = " ";
AutoFsm.separatorLabel = "Separator";
AutoFsm.nullStat = "null";
AutoFsm.startStat = "start";
AutoFsm.succStat = "succ";
AutoFsm.prototype.getEvent = function(curChar){
	if(curChar === AutoFsm.separatorVal)
		return AutoFsm.separatorLabel;
	return curChar;
};
AutoFsm.prototype.test = function(strLine, bWholeMatch){
	var iStartPos = -1;
	var iEndPos = -1;
	strLine = strLine + AutoFsm.separatorVal;
	
	var stat = AutoFsm.nullStat;
	for(var i = 0; i < strLine.length; i++)
	{
		var getCh = this.getEvent(strLine[i]);
		stat = (this.statJump[stat][getCh] ? this.statJump[stat][getCh] : AutoFsm.nullStat);
		if(stat === AutoFsm.startStat)
		{
			if(bWholeMatch)
				if(i !== 0)
					return false;
			
			iStartPos = i;
		}
		if(stat === AutoFsm.succStat)
		{
			if(bWholeMatch)
				if(i !== strLine.length-1)
					return false;
			iEndPos = i;
			break;
		}
		if(stat === AutoFsm.nullStat)
		{
			iStartPos = -1;
			iEndPos = -1;
		}
	}
	
	console.log((iEndPos >= 0 ? 'Matched in ' : 'Unmatched in ') + '"' +strLine  + '"' + ". String position is at (" + iStartPos + ", " + iEndPos + "), use substring() value: " + strLine.substring(iStartPos,iEndPos+1));
	return (iEndPos >= 0 ? true : false);
};

LispAutoFsm = {
	lNumber: {
		"null": {"1":"start","2":"start","3":"start","4":"start","5":"start","6":"start","7":"start","8":"start","9":"start"},
		"start":{"1":"S1","2":"S1","3":"S1","4":"S1","5":"S1","6":"S1","7":"S1","8":"S1","9":"S1","0":"S1", "Separator":AutoFsm.succStat},
		"S1":{"1":"S1","2":"S1","3":"S1","4":"S1","5":"S1","6":"S1","7":"S1","8":"S1","9":"S1","0":"S1", "Separator":AutoFsm.succStat}
	}
};


function Atom(strNotation){
 this.type = "";
 this.value = "";
 this.initByNotation(strNotation);
};
Atom.prototype.initByNotation = function(strNt)
{
 if(strNt[0] === '"')
 {
  this.type = "string";
  this.value = strNt.substring(1, strNt.length-1);
 }
 else if(/[\d]+/.test(strNt))
 {
  this.type = "number";
  this.value = parseFloat(strNt);
 }
  
};
Atom.prototype.getVal = function(){
 return this.value;
};
function Exp(strNotation){
 this.operator = null;
 this.operandObjArr = [];
 this.initByNotation(strNotation);
};
Exp.prototype.initByNotation = function(strNt)
{
 var thisRef = this;
 var optName = strNt.split(' ')[0].substr(1);
 switch(optName)
 {
  case '+':
   this.operator = GlobalFun.add
   break;
  case '-':
   this.operator = GlobalFun.minus
   break;
  case '*':
   this.operator = GlobalFun.mult
   break;
  case '/':
   this.operator = GlobalFun.div
   break;
  case 'Note':
   this.operator = GlobalFun.note;
 }
 
 var opr = strNt.split(' ');
 opr.splice(0, 1);
 var lastOne = opr[opr.length-1];
 opr[opr.length-1] = lastOne.substr(0, lastOne.length-1);//remove the last ')'
 opr.forEach(function(it){
  if(it[0] == '(')
   thisRef.operandObjArr.push(new Exp(it));
  else
   thisRef.operandObjArr.push(new Atom(it));
 });
};
Exp.prototype.getVal = function(){
 var paras = [];
 this.operandObjArr.forEach(function(it){
  paras.push(it.getVal());
 });
 return this.operator.apply(this, paras);
};
</script>

<script type="text/javascript">
function calcSimpleExp()
{
	var str = $("#simpleExp").val();
	var inputL = str.split('\n').pop();
	var v = (inputL[0] == '(' ? new Exp(inputL) : new Atom(inputL));
	$("#simpleExp").val(str + "\n" + v.getVal());
	
	debugger;
	var a = new AutoFsm({
		"null": {"d":"start"},
		"start":{"e":"1"},
		"1":{"f":"2"},
		"2":{"u":"3"},
		"3":{"n":"4"},
		"4":{"Separator":AutoFsm.succStat}
	});
	var bmatched = a.test("test defun keyword", false);
	
	var nTest = new AutoFsm(LispAutoFsm.lNumber);
	nTest.test("234nb 56", false);
};
</script>
</html>